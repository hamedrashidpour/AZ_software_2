# گزارش کار آزمایش
- ابتدا یک پروژه maven  در intelij ساختیم و junit را اضافه کردیم
- سپس به روش Test Driven Development یا TDD شروع به کد زدن کردیم:
    - ابتدا برای نوشتن کد های خود یک شاخه جدید به نام test ساختیم و روند پروژه را برروی آن ادامه دادیم.
    - قابلیت اول محاسبه مساحت برای مستطیل!
      - ساخت کلاس RectangleTest و نوشتن متود تست computeAreaTest و نوشتن یک تست برای آن که اجرای آن fail می شود:![Screenshot 2023-07-29 171225](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/36e8b794-2ec2-46fa-8066-216d03f3c077)
      - تغییر ساده کد برای pass شدن تست ها:![Screenshot 2023-07-29 205015](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/efd42a25-c85a-4b04-8d98-b92c1580f194)
      - اضافه کردن تست جدید!![Screenshot 2023-07-29 205309](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/d8623016-8354-4606-9446-fc30e98d5a20)
      - تغییر کد برای pass شده همه تست ها:![Screenshot 2023-07-29 210901](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/a1dd76d3-eb2d-4ee9-9fe4-725cb92ed0b8)
      - حال refactor کردن کد موردنظر:![Screenshot 2023-07-29 211423](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/3ff407f4-81d8-4e73-be22-db4ce2fb73f7)
    - حال قابلیت دوم که امکان تغییر height  و width مستطیل مورد نظر بود را به روش Test Driven Development یا TDD اضافه کردیم:
      - نوشتن تست:![Screenshot 2023-07-29 212911](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/d3c02333-2581-422e-8c10-d38bdd993821)
      - تغییر ساده کد برای pass شدن تست ها:![Screenshot 2023-07-29 213518](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/fd34322a-9375-4aee-aeb2-e6d35d205a39)
      - اضافه کردن تست جدید: ![Screenshot 2023-07-29 213812](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/c160b431-31c6-4cd7-bc2e-220ea0da6879)
      - تغییر کد:![Screenshot 2023-07-29 214030](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/c880024d-90d5-4a76-8451-8307525769ce)
      - حال کد مورد نظر کار می کرد اما داشتن متغییر های public مخالف oop است زیرا encapsulation را نقض می کند. پس کد را refactor می کنیم و متغییر ها را private کرده و getter setter اضافه می کنیم:![Screenshot 2023-07-30 084250](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/51089fcd-12b3-4435-9181-16a95a6d7c61)
      - تست اضافه می کنیم:![Screenshot 2023-07-30 085102](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/3809273c-c51d-45d0-b989-79c91b45b5e3)
      - تغییر کد:![Screenshot 2023-07-30 090033](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/623405e0-4626-4f89-8978-14f9047ff436)
در این مرحله به کدی برای کلاس Rectangle می رسیم که دو قابلیت قبلی را دارد.
    - حال قابلیت سوم را که مربع است اضافه می کنیم:
      - برای اضافه کردن این قابلیت راه های مختلفی وجود داشت:
        1. اضافه کردن یک متغییر shape در کلاس Rectangle و یک جمله شرطی که هنگامی که کاربر طول و عرض مستطیل را وارد می کند چک کنیم که اگر برابر بودند shape را برابر با مربع و در غیر اینصورت برابر با مستطیل قرار دهیم، همچنین در متود computeArea نحوه محاسبه مساحت را با توجه به مقدار متغیر shape تعیین کنیم. مشکل این روش نقض اصل OCP از قوانین SOLID می باشد زیرا مثلا اگر بخواهیم یک شکل دیگر را اضافه کنیم آنگاه ساختار داخلی کلاس، متد computeArea و جمله های شرطی همه باید تغییر کنند.
        2. روش دیگر این است که شکل مربع را به صورت یک کلاس جدا ایجاد کنیم و با پیروی از اینکه "هر مربع یک مستطیل" است، کلاس مربع از مستطیل ارث بری کند! در اینصورت مشکل حل شده به نظر می رسد اما این کار قانون LSP از قوانین SOLID را نقض می کند زیرا اولا ما برای ارث بری داریم که کلاس فرزند نباید pre condtion های قوی تری نسبت به کلاس پدر داشته باشد در صورتی که در این مورد مربع دارای شرط برابر بودن طول و عرض است که مستطیل این شرط را ندارد، همچنین کلاس فرزند نباید خدمات کمتری نسبت به کلاس فرزند ارایه دهد اما در این مورد، برای مثال ما امکان تغییر طول و عرض را به صورت جداگانه برای مستطیل داریم اما برای مربع خیر، امکان اینکه با ثابت بودن یکی (طول و عرض) دیگری را تغییر دهیم داریم اما برای مربع خیر، همچنین مثلا می دانیم که با دوبرابر شدن طول یا عرض مستطیل مساحت آن دو برابر می شود که این قانون برای مربع صادق نمی باشد زیرا با تغییر در ضلع مربع مساحت آن به توان 2 تغییر می کند، پس در آخر به این نتیجه می رسیم که مربع نمی تواند فرزند مستطیل باشد.
        3. ما در این مورد ابتدا کلاس مربع را به صورت جدا ایجاد می کنیم و بدون وابستگی به مستطیل گسترش می دهیم و در آخر چک می کنیم که آیا مشکلی پیش می آید یا خیر!!!
      - ابتدا برنچ test را با main  مرج کردیم و برای اضافه کردن مربع یک برنچ جدید به نام square ساختیم.
      - کلاس SquareTest را ایجاد کرد و اولین تست را اجرا می کنیم:![Screenshot 2023-07-30 111531 square](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/b197daf6-db5b-4834-8b9a-1c6b828605c5)
      - کد را برای pass کردن تست ها تغییر می دهیم:![Screenshot 2023-07-30 111913](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/e2383c63-b957-4bf9-baad-b3f979814e4a)
      - در آخر refactor کردن کد در صورت نیاز
      - مراحل بالا را چندین بار تکرار می کنیم تا به کد نهایی برسیم:![Screenshot 2023-07-30 113428](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/5f837549-1c52-44b4-934f-064a233a3744) ![Screenshot 2023-07-30 133847](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/bcb031ee-03ee-4bba-9a09-b09b71b5eeac)
      - در آخر برنچ square را با main مرج کردیم.
      - همانطور که در بالا دیده می شود تمام تست ها pass شده اند.
        1. هم شکل مربع و هم شکل مستطیل دارای متد computeArea می باشند که با روش های مختلف پیاده سازی کرده اند.     -> یک interface به نام Area ایجاد کرده که دارای متود computeArea باشد و کلاس های مربع و مستطیل را به گونه ای تغییر می دهیم که اینترفیس را implement کرده و تابع را پیاده شازی کنند.
        2. هم شکل مربع و هم شکل مستطیل دارای ضلع هستند -> یک کلاس ضلع می سازیم که دارای متغیر طول می باشد که مربع با توجه به برابر بودن تمام اضلاعش یک شی از آن و مستطیل دو شی از آن را درون خود دارد.
      - دو کلاس Rectangle و Square را با توجه به تغییرات بوجود آمده refactor می کنیم و چک می کنیم که تست ها نیز پس از این تغییرا pass شوند.![Screenshot 2023-07-30 152032](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/0a0da6a5-867e-40c2-903a-61d922248bb4)
      - تغییرات بالا را برروی برنچ refactor انجام دادیم و در آخر با main مرج کردیم.
    
کد به دست آمده تمام نیاز های مسیله را برآورده کرده و از قوانین SOLID پیروی می کند همچنین رویکرد refactor کردن در کلاس ها در مرحله آخر composition است، با توجه به اینکه هم مستطیل و هم مربع دارای ضلع می باشند و هردو مساحت دارند. ( می توانستیم با این نگاه که هم مربع و هم مستطیل شکل هندسی هستند و هر شکل هندسی مساحت دارد از ارث بری استفاده کنیم که ما composition را دارای پیچیدگی کمتر دانسته و استفاده کردیم.)

در آخر نیز گزارش کار نوشته شد و به سوالات آخر گزارش نیز پاسخ دادیم.

# پاسخ سوالات آخر گزارش
3. خیر این دو مفهوم با یکدیگر کاملا متفاوت هستند 

زیرا اگر بهچرخه‌ی عمومی ایجاد نرم‌افزار دقت کنیم:![Software-Development-Life-Cycle](https://github.com/hamedrashidpour/AZ_software_2/assets/45601809/be822370-ab81-42ff-b4d3-360e53ecbb52)

انجام تست بعد از پیاده سازی صورت می گیرد این در حالی است که TDD خودش یک vوش پیاده سازی است و انجام تست قبل از زدن کد و پیاده سازی که به این روش انجام می شود همه در قسمت implementation چرخه انجام می شود و تست های جامع و verification طبق روال چرخه بعد از پیاده سازی صورت می گیرد در نتیجه این دو مفهوم با یکدیگر تناقضی ندارند.

4. با توجه به اینکه طول و عرض مستطیل دیگر قابل تغییر نیستند یعنی به عبارتی طول و عرض هر مستطیل مانند id برای آن عمل میکنند و درنتیجه مشکلات مربوط به تغییر مساحت یا تغییر طول و عرض به صورت جداگانه که در ارث بری مربع از مستطیل مشکل ایجاد میکرد وجود ندارد و مربع می تواند از مستطیل ارث بری کند بدون اینکه مشکلی پش آید اما باز هم از لحاظ مفهومی و نحوه فکر کردن بنظر منطقی نمی آید انجام اینکار زیرا این عمل maintanance  سیستم را ممکن از دچار مشکل کند و سیستم را درمقابل تغییر بی دفاع تر میکند.
